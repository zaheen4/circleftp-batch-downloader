import subprocess
import os
import time
import tempfile # Still useful for gettempdir() for general temp operations, though not for batch list

from bs4 import BeautifulSoup

# Selenium Imports
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.firefox.service import Service as FirefoxService
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException

# --- Configuration ---
# IMPORTANT: Replace this with the actual path to your idman.exe
IDM_PATH = r"C:\Program Files (x86)\Internet Download Manager\idman.exe"

# --- WebDriver Paths Configuration ---
# Assuming you place your WebDriver executables in a 'drivers' subfolder
DRIVER_DIR = "drivers" # Name of the subfolder for drivers

CHROMEDRIVER_PATH = os.path.join(DRIVER_DIR, "chromedriver.exe")
GECKODRIVER_PATH = os.path.join(DRIVER_DIR, "geckodriver.exe")
EDGEDRIVER_PATH = os.path.join(DRIVER_DIR, "msedgedriver.exe")

# --- Helper Function: Get Full HTML Content using Selenium ---
def get_full_html_content_selenium(url, browser_type):
    """
    Fetches the fully rendered HTML content of a given URL using a headless Selenium browser.
    Supports Chrome, Firefox, and Edge.
    Returns the HTML content as a string, or None if an error occurs.
    """
    print(f"Opening headless {browser_type} with Selenium to fetch: {url}")
    driver = None # Initialize driver to None

    try:
        if browser_type.lower() == 'chrome':
            service = ChromeService(executable_path=CHROMEDRIVER_PATH)
            options = webdriver.ChromeOptions()
            options.add_argument("--headless")
            options.add_argument("--disable-gpu")
            options.add_argument("--log-level=3")
            options.add_argument("--disable-logging")
            driver = webdriver.Chrome(service=service, options=options)
        elif browser_type.lower() == 'firefox':
            service = FirefoxService(executable_path=GECKODRIVER_PATH)
            options = webdriver.FirefoxOptions()
            options.add_argument("-headless") # Firefox uses -headless
            options.add_argument("--log-level=3")
            driver = webdriver.Firefox(service=service, options=options)
        elif browser_type.lower() == 'edge':
            service = EdgeService(executable_path=EDGEDRIVER_PATH)
            options = webdriver.EdgeOptions()
            options.add_argument("--headless")
            options.add_argument("--disable-gpu")
            options.add_argument("--log-level=3")
            options.add_argument("--disable-logging")
            driver = webdriver.Chrome(service=service, options=options) # NOTE: Edge uses ChromeDriver interface
        else:
            print(f"ERROR: Unsupported browser type: {browser_type}. Please choose 'chrome', 'firefox', or 'edge'.")
            return None

        driver.get(url)

        # Robust Waiting Strategy for the main content section
        wait = WebDriverWait(driver, 20) # Wait up to 20 seconds
        wait.until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "section.bg-light.mt-2.rounded.p-2.w-75.mx-auto"))
        )
        print("Main download section loaded in browser. Extracting HTML.")

        full_html = driver.page_source
        print("Successfully fetched full HTML via Selenium.")

        return full_html

    except FileNotFoundError as e:
        print(f"ERROR: WebDriver for {browser_type} not found at '{e.filename}'.")
        print("Make sure the correct WebDriver executable is downloaded and placed in the 'drivers' subfolder.")
        return None
    except TimeoutException:
        print(f"ERROR: Timeout waiting for the download section to appear on {url}.")
        print("The page might be taking too long to load, or the CSS selector is incorrect.")
        return None
    except WebDriverException as e:
        print(f"ERROR: Selenium WebDriver failed for {browser_type}: {e}")
        print(f"This could be due to a version mismatch between {browser_type} browser and its WebDriver, or other browser issues.")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during Selenium fetching for {browser_type}: {e}")
        return None
    finally:
        if driver:
            driver.quit() # Ensure the browser instance is closed

# --- Function: Extract Download Links from HTML (unchanged) ---
def extract_download_links_from_html(html_content):
    """
    Parses the HTML content to find download URLs for game parts.
    This logic is specific to the 'Witcherdownload page.htm' pattern and
    expects the HTML to be fully rendered.
    """
    soup = BeautifulSoup(html_content, 'html.parser')
    download_urls = []

    download_section = soup.find('section', class_='bg-light mt-2 rounded p-2 w-75 mx-auto')

    if not download_section:
        print("WARNING: 'download_section' was not found by BeautifulSoup.")
        print("This indicates the HTML structure might have changed or the Selenium wait was insufficient.")
        return []

    links = download_section.find_all('a', class_='btn btn-success', href=True)

    if not links:
        print("WARNING: No 'btn btn-success' download links found within the identified section.")
        print("The link pattern within the download section might need adjustment.")

    for link in links:
        url = link['href']
        if url:
            download_urls.append(url)

    return list(set(download_urls))

# --- Function: Initiate Direct Download for Each URL using IDM CLI ---
def initiate_idm_direct_downloads(urls, idm_exec_path):
    """
    Initiates a direct download for each URL using IDM's command-line interface.
    Each download will be a separate entry in IDM.
    IDM will use its own configured default download directory.
    """
    if not urls:
        print("No URLs provided for download to IDM.")
        return

    print(f"\nInitiating {len(urls)} direct downloads via IDM...")

    for i, url in enumerate(urls):
        # Optionally, try to extract a filename from the URL, or let IDM decide
        # For simplicity, we'll let IDM infer the filename,
        # but you could use url.split('/')[-1] if needed.
        # IDM usually does a good job of extracting filenames automatically.

        command = [
            idm_exec_path,
            '/d', url,   # Use /d for direct download
            '/n',        # Do not show confirmation dialog
            '/q',        # Quiet mode (no download progress dialog)
            '/s'         # Start download immediately
        ]

        try:
            print(f"[{i+1}/{len(urls)}] Sending direct download for: {url}")
            # We don't need capture_output or check=True here because we're doing one by one.
            # Errors for individual commands will be printed.
            subprocess.run(command, creationflags=subprocess.CREATE_NO_WINDOW)
            # Add a small delay between sending commands to IDM, to avoid overwhelming it
            time.sleep(0.5) # Wait 0.5 seconds
        except FileNotFoundError:
            print(f"ERROR: IDM executable not found at '{idm_exec_path}'. Skipping this download.")
            break # No point in continuing if IDM isn't found
        except Exception as e:
            print(f"ERROR: Failed to send direct download for {url} to IDM: {e}")
            # Continue to next URL even if one fails

    print("\nAll download requests sent to IDM.")
    print("Files should be starting in IDM according to its internal 'Save To' settings.")


# --- Main Execution Flow ---
if __name__ == "__main__":
    print("--- Circle FTP Mass Downloader ---")
    print("This script fetches download links from a given URL and sends them to IDM.")

    # Get URL from user input
    target_website_url = input("Please enter the full URL of the content page: ")

    # Prompt user for browser choice with numbers
    while True:
        print("\nChoose a browser:")
        print("1. Chrome")
        print("2. Firefox")
        print("3. Edge")
        browser_choice_num = input("Enter the number of your choice (1, 2, or 3): ").strip()

        if browser_choice_num == '1':
            browser_choice = 'chrome'
            break
        elif browser_choice_num == '2':
            browser_choice = 'firefox'
            break
        elif browser_choice_num == '3':
            browser_choice = 'edge'
            break
        else:
            print("Invalid input. Please enter '1', '2', or '3'.")

    # Ensure the drivers directory exists (good practice for initial setup)
    os.makedirs(DRIVER_DIR, exist_ok=True)

    # Step 1: Get the full HTML using Selenium with the chosen browser
    html_content = get_full_html_content_selenium(target_website_url, browser_choice)

    if html_content:
        # Step 2: Extract download links from the fetched HTML
        extracted_download_urls = extract_download_links_from_html(html_content)

        if extracted_download_urls:
            print(f"\nFound {len(extracted_download_urls)} download URLs:")
            for url in extracted_download_urls:
                print(f"- {url}")

            # Step 3: Initiate the download process with IDM using direct downloads
            initiate_idm_direct_downloads(extracted_download_urls, IDM_PATH)
        else:
            print("No download links were extracted from the provided URL.")
            print("This might happen if the HTML structure has changed, or the page loaded differently.")
    else:
        print("Failed to retrieve HTML content. Cannot proceed with download link extraction.")

    print("\n--- Script Finished ---")